'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var hoistNonReactStatics = _interopDefault(require('hoist-non-react-statics'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function setBatchedUpdater(updater) {
  exports.batchedUpdater = updater;
}

var PluginManager = /*#__PURE__*/function () {
  function PluginManager() {
    this._plugins = [];
  }

  var _proto = PluginManager.prototype;

  _proto.use = function use(plugin) {
    this._plugins.push(plugin);
  };

  _proto.onCreate = function onCreate(observable, val) {
    this._plugins.forEach(function (it) {
      return it.onCreate == null ? void 0 : it.onCreate(observable, val);
    });
  };

  _proto.onChange = function onChange(observable, val, prevVal) {
    this._plugins.forEach(function (it) {
      return it.onChange == null ? void 0 : it.onChange(observable, val, prevVal);
    });
  };

  _proto.onBecomeObserved = function onBecomeObserved(observable) {
    this._plugins.forEach(function (it) {
      return it.onBecomeObserved == null ? void 0 : it.onBecomeObserved(observable);
    });
  };

  _proto.onBecomeUnobserved = function onBecomeUnobserved(observable) {
    this._plugins.forEach(function (it) {
      return it.onBecomeUnobserved == null ? void 0 : it.onBecomeUnobserved(observable);
    });
  };

  _proto.onAttach = function onAttach(observable, input) {
    this._plugins.forEach(function (it) {
      return it.onAttach == null ? void 0 : it.onAttach(observable, input);
    });
  };

  _proto.onDetach = function onDetach(observable, input) {
    this._plugins.forEach(function (it) {
      return it.onDetach == null ? void 0 : it.onDetach(observable, input);
    });
  };

  return PluginManager;
}();

var UNSET = /*#__PURE__*/Symbol();
var plugins = /*#__PURE__*/new PluginManager();
var capturedInputFrames = [];
var shouldCaptureNextInput = false;
var batchedObservables = [];
var batchDepth = 0;
var BaseObservable = /*#__PURE__*/function () {
  function BaseObservable(val, options) {
    if (options === void 0) {
      options = {};
    }

    this._prevVal = UNSET;
    this._inputs = [];
    this._outputs = [];
    this._listeners = [];
    this._attachedToInputs = false;
    /**
     * @deprecated Use observable.subscribe() instead
     */

    this.onChange = this.subscribe;
    this._val = val;
    this._options = options;
    plugins.onCreate(this, val);
  }

  var _proto = BaseObservable.prototype;

  _proto.get = function get() {
    var capturedInputs = capturedInputFrames[capturedInputFrames.length - 1];

    if (capturedInputs && shouldCaptureNextInput) {
      try {
        shouldCaptureNextInput = false;
        capturedInputs.push(this);
        return this._get();
      } finally {
        shouldCaptureNextInput = true;
      }
    } else {
      return this._get();
    }
  };

  _proto._get = function _get() {
    var shouldEvaluate = !this._attachedToInputs || this._prevVal !== UNSET;
    return shouldEvaluate ? this._evaluate() : this._val;
  };

  _proto._evaluate = function _evaluate() {
    return this._val;
  };

  _proto._set = function _set(val) {
    if (this._val !== val) {
      this._addToBatchRecursively();

      this._val = val;
    }
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this._listeners.push(listener);

    this._attachToInputs();

    var listenerRemoved = false;
    return function () {
      if (!listenerRemoved) {
        listenerRemoved = true;

        _this._listeners.splice(_this._listeners.indexOf(listener), 1);

        _this._detachFromInputs();
      }
    };
  };

  _proto.onBecomeObserved = function onBecomeObserved() {// Called when the first listener subscribes to the observable or to one of its outputs
  };

  _proto.onBecomeUnobserved = function onBecomeUnobserved() {// Called when the last listener unsubscribes from the observable and from all of its outputs
  };

  _proto.getInputs = function getInputs() {
    return this._inputs;
  };

  _proto.getOptions = function getOptions() {
    return this._options;
  };

  _proto.withOptions = function withOptions(options) {
    this._options = _extends({}, this._options, options);
    return this;
  };

  BaseObservable._captureInputs = function _captureInputs(block) {
    try {
      var capturedInputs = [];
      capturedInputFrames.push(capturedInputs);
      shouldCaptureNextInput = true;
      block();
      return capturedInputs;
    } finally {
      capturedInputFrames.pop();
      shouldCaptureNextInput = false;
    }
  };

  _proto._addInput = function _addInput(input) {
    this._inputs.push(input);

    if (this._attachedToInputs) {
      this._attachToInput(input);
    }
  };

  _proto._removeInput = function _removeInput(input) {
    this._inputs.splice(this._inputs.indexOf(input), 1);

    if (this._attachedToInputs) {
      this._detachFromInput(input);
    }
  };

  _proto._shouldAttachToInputs = function _shouldAttachToInputs() {
    // Only attach to inputs when at least one listener is subscribed to the observable or to one of its outputs.
    // This is done to avoid unused observables being references by their inputs, preventing garbage-collection.
    return this._listeners.length > 0 || this._outputs.length > 0;
  };

  _proto._attachToInputs = function _attachToInputs() {
    if (!this._attachedToInputs && this._shouldAttachToInputs()) {
      this._attachedToInputs = true; // Since the observable was not attached to its inputs, its value may be outdated.
      // Refresh it so that listeners will be called with the correct prevValue the next time an input changes.

      this._val = this._evaluate();
      this.onBecomeObserved();
      plugins.onBecomeObserved(this);

      for (var _iterator = _createForOfIteratorHelperLoose(this._inputs), _step; !(_step = _iterator()).done;) {
        var input = _step.value;

        this._attachToInput(input);

        input._attachToInputs();
      }
    }
  };

  _proto._detachFromInputs = function _detachFromInputs() {
    if (this._attachedToInputs && !this._shouldAttachToInputs()) {
      this._attachedToInputs = false;

      for (var _iterator2 = _createForOfIteratorHelperLoose(this._inputs), _step2; !(_step2 = _iterator2()).done;) {
        var input = _step2.value;

        this._detachFromInput(input);

        input._detachFromInputs();
      }

      this.onBecomeUnobserved();
      plugins.onBecomeUnobserved(this);
    }
  };

  _proto._attachToInput = function _attachToInput(input) {
    input._outputs.push(this);

    plugins.onAttach(this, input);
  };

  _proto._detachFromInput = function _detachFromInput(input) {
    input._outputs.splice(input._outputs.indexOf(this), 1);

    plugins.onDetach(this, input);
  };

  _proto._addToBatchRecursively = function _addToBatchRecursively() {
    if (this._prevVal === UNSET) {
      this._prevVal = this._val; // Add the observable and its outputs in reverse topological order

      for (var _iterator3 = _createForOfIteratorHelperLoose(this._outputs), _step3; !(_step3 = _iterator3()).done;) {
        var output = _step3.value;

        output._addToBatchRecursively();
      }

      batchedObservables.push(this);
    }
  };

  BaseObservable._batch = function _batch(block) {
    try {
      batchDepth++;

      if (batchDepth === 1 && exports.batchedUpdater) {
        exports.batchedUpdater(block);
      } else {
        block();
      }
    } finally {
      batchDepth--;

      if (batchDepth === 0) {
        var observablesToUpdate = batchedObservables;
        batchedObservables = []; // Iterate in reverse order as _addToBatchRecursively() adds them in reverse topological order

        for (var i = observablesToUpdate.length - 1; i >= 0; i--) {
          var observable = observablesToUpdate[i];
          var prevVal = observable._prevVal;
          observable._prevVal = UNSET;
          observable._val = observable._evaluate();
          var val = observable._val;

          if (val !== prevVal) {
            for (var _iterator4 = _createForOfIteratorHelperLoose(observable._listeners.slice()), _step4; !(_step4 = _iterator4()).done;) {
              var listener = _step4.value;
              listener(val, prevVal);
            }

            plugins.onChange(observable, val, prevVal);
          }
        }
      }
    }
  };

  BaseObservable._use = function _use(plugin) {
    plugins.use(plugin);
  };

  return BaseObservable;
}();

function memoize(func) {
  var lastArgs;
  var lastResult;
  return function (args) {
    var argsHaveChanged = false;

    if (!lastArgs || args.length !== lastArgs.length) {
      argsHaveChanged = true;
    } else {
      for (var i = 0; i < args.length; i++) {
        if (args[i] !== lastArgs[i]) {
          argsHaveChanged = true;
          break;
        }
      }
    }

    if (argsHaveChanged) {
      lastArgs = args;
      lastResult = func(args);
    }

    return lastResult;
  };
}

function observable(val, options) {
  return new WritableObservable(val, options);
}
function derived(derive) {
  return Observable.compute(derive);
}
var Observable = /*#__PURE__*/function (_BaseObservable) {
  _inheritsLoose(Observable, _BaseObservable);

  function Observable(val, options) {
    var _this;

    _this = _BaseObservable.call(this, val instanceof Observable ? val.get() : val, options) || this;
    /**
     * @deprecated Use observable.select() instead
     */

    _this.transform = _this.select;

    _this._updateValInput(val);

    return _this;
  }

  var _proto = Observable.prototype;

  _proto._evaluate = function _evaluate() {
    return this._valInput ? this._valInput.get() : _BaseObservable.prototype._evaluate.call(this);
  };

  _proto.select = function select(selector) {
    return new DerivedObservable([this], function (_ref) {
      var val = _ref[0];
      return selector(val);
    });
  };

  _proto.onlyIf = function onlyIf(predicate) {
    var filteredVal = undefined;
    return this.select(function (val) {
      if (predicate(val)) {
        filteredVal = val;
      }

      return filteredVal;
    });
  };

  _proto["default"] = function _default(defaultVal) {
    return this.select(function (val) {
      return val != null ? val : defaultVal;
    });
  };

  _proto.as = function as() {
    return this;
  };

  Observable.select = function select(observables, selector) {
    return new DerivedObservable(observables, function (vals) {
      return selector.apply(void 0, vals);
    });
  }
  /**
   * @deprecated Use Observable.select() instead
   */
  ;

  Observable.from = function from() {
    for (var _len = arguments.length, observables = new Array(_len), _key = 0; _key < _len; _key++) {
      observables[_key] = arguments[_key];
    }

    return new DerivedObservable(observables, function (values) {
      return values;
    });
  };

  Observable.merge = function merge(observables) {
    return new DerivedObservable(observables, function (values) {
      return values;
    });
  };

  Observable.latest = function latest() {
    var prevValues;

    for (var _len2 = arguments.length, observables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      observables[_key2] = arguments[_key2];
    }

    return new DerivedObservable(observables, function (values) {
      var val = !prevValues ? values[0] : values.find(function (it, index) {
        return it !== prevValues[index];
      });
      prevValues = values;
      return val;
    });
  };

  Observable.compute = function compute(_compute) {
    return new ComputedObservable(_compute);
  };

  Observable.fromPromise = function fromPromise(promise, onError) {
    var obs = observable(undefined);
    promise.then(function (val) {
      return obs.set(val);
    }, function (e) {
      return onError && obs.set(onError(e));
    });
    return obs;
  };

  _proto.toPromise = function toPromise() {
    var _this2 = this;

    return new Promise(function (resolve) {
      var unsubscribe = _this2.subscribe(function (val) {
        resolve(val);
        unsubscribe();
      });
    });
  };

  Observable.batch = function batch(block) {
    BaseObservable._batch(block);
  };

  Observable.use = function use(plugin) {
    BaseObservable._use(plugin);
  };

  _proto._updateValInput = function _updateValInput(val) {
    if (this._valInput !== val) {
      if (this._valInput) {
        this._removeInput(this._valInput);

        this._valInput = undefined;
      }

      if (val instanceof Observable) {
        this._addInput(val);

        this._valInput = val;
      }
    }
  };

  return Observable;
}(BaseObservable);
var WritableObservable = /*#__PURE__*/function (_Observable) {
  _inheritsLoose(WritableObservable, _Observable);

  function WritableObservable() {
    return _Observable.apply(this, arguments) || this;
  }

  var _proto2 = WritableObservable.prototype;

  _proto2.set = function set(val) {
    var _this3 = this;

    this._updateValInput(val);

    Observable.batch(function () {
      return _this3._set(val instanceof Observable ? val.get() : val);
    });
  };

  _proto2.update = function update(updater) {
    this.set(updater(this.get()));
  };

  _proto2.readOnly = function readOnly() {
    return this;
  };

  return WritableObservable;
}(Observable);

var DerivedObservable = /*#__PURE__*/function (_Observable2) {
  _inheritsLoose(DerivedObservable, _Observable2);

  function DerivedObservable(computeInputs, compute) {
    var _this4;

    // No need to initialize it as it will be evaluated the first time get() or subscribe() is called
    _this4 = _Observable2.call(this, undefined) || this;
    _this4._compute = memoize(compute);
    _this4._computeInputs = computeInputs;

    for (var _iterator = _createForOfIteratorHelperLoose(computeInputs), _step; !(_step = _iterator()).done;) {
      var input = _step.value;

      _this4._addInput(input);
    }

    return _this4;
  }

  var _proto3 = DerivedObservable.prototype;

  _proto3._evaluate = function _evaluate() {
    var computed = this._compute(this._computeInputs.map(function (input) {
      return input.get();
    }));

    this._updateValInput(computed);

    return computed instanceof Observable ? computed.get() : computed;
  };

  return DerivedObservable;
}(Observable);

var ComputedObservable = /*#__PURE__*/function (_Observable3) {
  _inheritsLoose(ComputedObservable, _Observable3);

  function ComputedObservable(compute) {
    var _this5;

    // No need to initialize it as it will be evaluated the first time get() or subscribe() is called
    _this5 = _Observable3.call(this, undefined) || this;
    _this5._currentInputs = new Set();
    _this5._compute = compute;
    return _this5;
  }

  var _proto4 = ComputedObservable.prototype;

  _proto4._evaluate = function _evaluate() {
    var _this6 = this;

    var value;
    var inputs = new Set(BaseObservable._captureInputs(function () {
      return value = _this6._compute();
    }));
    inputs.forEach(function (input) {
      if (!_this6._currentInputs.has(input)) {
        _this6._addInput(input);
      } else {
        _this6._currentInputs["delete"](input);
      }
    });

    this._currentInputs.forEach(function (input) {
      return _this6._removeInput(input);
    });

    this._currentInputs = inputs;
    return value;
  };

  return ComputedObservable;
}(Observable);

function useObservable(observable) {
  var _useState = React.useState({}),
      forceRender = _useState[1];

  var val = observable.get();
  React.useLayoutEffect(function () {
    return observable.subscribe(function () {
      return forceRender({});
    });
  }, [observable]);
  return val;
}
function useMemoizedObservable(factory, deps) {
  if (deps === void 0) {
    deps = [];
  }

  return useObservable(React.useMemo(factory, deps));
}
function useComputedObservable(compute, deps) {
  if (deps === void 0) {
    deps = [];
  }

  return useMemoizedObservable(function () {
    return Observable.compute(compute);
  }, deps);
}

// Code ported from React source-code
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (var i = 0; i < keysA.length; i++) {
    if (!objB.hasOwnProperty(keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

var withObservables = function withObservables(Component, mapping) {
  var WithObservables = /*#__PURE__*/function (_React$PureComponent) {
    _inheritsLoose(WithObservables, _React$PureComponent);

    function WithObservables() {
      var _this;

      _this = _React$PureComponent.apply(this, arguments) || this;
      _this._unsubscribers = [];
      return _this;
    }

    var _proto = WithObservables.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._unsubscribers.forEach(function (it) {
        return it();
      });

      this._unsubscribers = [];
    };

    _proto.render = function render() {
      this.updateMapping();
      var injectedProps = {};

      for (var _i = 0, _Object$keys = Object.keys(this._mapping); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        injectedProps[key] = this._mapping[key].get();
      }

      return React__default.createElement(Component, _extends({}, this.props, injectedProps));
    };

    _proto.updateMapping = function updateMapping() {
      var _this2 = this;

      if (!this._ownProps || !shallowEqual(this._ownProps, this.props)) {
        this._ownProps = this.props;
        this._mapping = typeof mapping === "function" ? mapping(this.props) : mapping;
        var unsubscribers = Object.values(this._mapping).map(function (observable) {
          return observable.subscribe(function () {
            return _this2.forceUpdate();
          });
        });

        this._unsubscribers.forEach(function (it) {
          return it();
        });

        this._unsubscribers = unsubscribers;
      }
    };

    return WithObservables;
  }(React__default.PureComponent);

  return hoistNonReactStatics(WithObservables, Component);
};

exports.BaseObservable = BaseObservable;
exports.Observable = Observable;
exports.WritableObservable = WritableObservable;
exports.derived = derived;
exports.observable = observable;
exports.setBatchedUpdater = setBatchedUpdater;
exports.useComputedObservable = useComputedObservable;
exports.useMemoizedObservable = useMemoizedObservable;
exports.useObservable = useObservable;
exports.withObservables = withObservables;
//# sourceMappingURL=micro-observables.cjs.development.js.map
