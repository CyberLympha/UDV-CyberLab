import { BaseObservable, Options } from "./baseObservable";
import { Plugin } from "./plugin";
export declare type ObservableValue<T> = T extends Observable<infer U> ? U : never;
export declare type ObservableValues<T> = {
    [K in keyof T]: ObservableValue<T[K]>;
};
export declare function observable<T>(val: T | Observable<T>, options?: Options): WritableObservable<T>;
export declare function derived<T>(derive: () => T): Observable<T>;
export declare class Observable<T> extends BaseObservable<T> {
    protected _valInput: Observable<T> | undefined;
    constructor(val: T | Observable<T>, options?: Options);
    protected _evaluate(): T;
    select<U>(selector: (val: T) => U | Observable<U>): Observable<U>;
    /**
     * @deprecated Use observable.select() instead
     */
    transform: <U>(selector: (val: T) => U | Observable<U>) => Observable<U>;
    onlyIf(predicate: (val: T) => boolean): Observable<T | undefined>;
    default(defaultVal: NonNullable<T> | Observable<NonNullable<T>>): Observable<NonNullable<T>>;
    as<U extends T>(): Observable<U>;
    static select<T extends readonly Observable<any>[], U>(observables: [...T], selector: (...vals: ObservableValues<T>) => U): Observable<U>;
    /**
     * @deprecated Use Observable.select() instead
     */
    static from<T extends Observable<any>[]>(...observables: T): Observable<ObservableValues<T>>;
    static merge<T>(observables: Observable<T>[]): Observable<T[]>;
    static latest<T extends Observable<any>[]>(...observables: T): Observable<ObservableValue<T[number]>>;
    static compute<U>(compute: () => U): Observable<U>;
    static fromPromise<T, E = undefined>(promise: Promise<T>, onError?: (error: any) => E): Observable<T | E | undefined>;
    toPromise(): Promise<T>;
    static batch(block: () => void): void;
    static use(plugin: Plugin): void;
    protected _updateValInput(val: T | Observable<T>): void;
}
export declare class WritableObservable<T> extends Observable<T> {
    set(val: T | Observable<T>): void;
    update(updater: (val: T) => T | Observable<T>): void;
    readOnly(): Observable<T>;
}
