{"version":3,"file":"micro-observables.cjs.production.min.js","sources":["../src/pluginManager.ts","../src/baseObservable.ts","../src/observable.ts","../src/memoize.ts","../src/useObservable.ts","../src/shallowEqual.ts","../src/batchedUpdater.ts","../src/withObservables.ts"],"sourcesContent":["import { BaseObservable } from \"./baseObservable\";\nimport { Plugin } from \"./plugin\";\n\nexport class PluginManager {\n  private _plugins: Plugin[] = [];\n\n  use(plugin: Plugin) {\n    this._plugins.push(plugin);\n  }\n\n  onCreate(observable: BaseObservable<any>, val: any) {\n    this._plugins.forEach(it => it.onCreate?.(observable, val));\n  }\n\n  onChange(observable: BaseObservable<any>, val, prevVal) {\n    this._plugins.forEach(it => it.onChange?.(observable, val, prevVal));\n  }\n\n  onBecomeObserved(observable: BaseObservable<any>) {\n    this._plugins.forEach(it => it.onBecomeObserved?.(observable));\n  }\n\n  onBecomeUnobserved(observable: BaseObservable<any>) {\n    this._plugins.forEach(it => it.onBecomeUnobserved?.(observable));\n  }\n\n  onAttach(observable: BaseObservable<any>, input: BaseObservable<any>) {\n    this._plugins.forEach(it => it.onAttach?.(observable, input));\n  }\n\n  onDetach(observable: BaseObservable<any>, input: BaseObservable<any>) {\n    this._plugins.forEach(it => it.onDetach?.(observable, input));\n  }\n}\n","import { batchedUpdater } from \"./batchedUpdater\";\nimport { Plugin } from \"./plugin\";\nimport { PluginManager } from \"./pluginManager\";\n\nconst UNSET = Symbol();\n\nconst plugins = new PluginManager();\n\nconst capturedInputFrames: BaseObservable<any>[][] = [];\nlet shouldCaptureNextInput = false;\n\nlet batchedObservables: BaseObservable<any>[] = [];\nlet batchDepth = 0;\n\nexport type Listener<T> = (val: T, prevVal: T) => void;\nexport type Unsubscriber = () => void;\nexport type Options = { [key: string]: any };\n\nexport class BaseObservable<T> {\n  private _val: T;\n  private _prevVal: T | typeof UNSET = UNSET;\n  private _options: Options;\n  private _inputs: BaseObservable<any>[] = [];\n  private _outputs: BaseObservable<any>[] = [];\n  private _listeners: Listener<T>[] = [];\n  private _attachedToInputs = false;\n\n  constructor(val: T, options: Options = {}) {\n    this._val = val;\n    this._options = options;\n    plugins.onCreate(this, val);\n  }\n\n  get(): T {\n    const capturedInputs = capturedInputFrames[capturedInputFrames.length - 1];\n    if (capturedInputs && shouldCaptureNextInput) {\n      try {\n        shouldCaptureNextInput = false;\n        capturedInputs.push(this);\n        return this._get();\n      } finally {\n        shouldCaptureNextInput = true;\n      }\n    } else {\n      return this._get();\n    }\n  }\n\n  protected _get(): T {\n    const shouldEvaluate = !this._attachedToInputs || this._prevVal !== UNSET;\n    return shouldEvaluate ? this._evaluate() : this._val;\n  }\n\n  protected _evaluate(): T {\n    return this._val;\n  }\n\n  protected _set(val: T) {\n    if (this._val !== val) {\n      this._addToBatchRecursively();\n      this._val = val;\n    }\n  }\n\n  subscribe(listener: Listener<T>): Unsubscriber {\n    this._listeners.push(listener);\n    this._attachToInputs();\n\n    let listenerRemoved = false;\n    return () => {\n      if (!listenerRemoved) {\n        listenerRemoved = true;\n        this._listeners.splice(this._listeners.indexOf(listener), 1);\n        this._detachFromInputs();\n      }\n    };\n  }\n\n  /**\n   * @deprecated Use observable.subscribe() instead\n   */\n  onChange = this.subscribe;\n\n  protected onBecomeObserved() {\n    // Called when the first listener subscribes to the observable or to one of its outputs\n  }\n\n  protected onBecomeUnobserved() {\n    // Called when the last listener unsubscribes from the observable and from all of its outputs\n  }\n\n  getInputs(): BaseObservable<any>[] {\n    return this._inputs;\n  }\n\n  getOptions<O extends Options = Options>(): O {\n    return this._options as O;\n  }\n\n  withOptions<O extends Options = Options>(options: Partial<O>): this {\n    this._options = { ...this._options, ...options };\n    return this;\n  }\n\n  protected static _captureInputs<T>(block: () => T): BaseObservable<any>[] {\n    try {\n      const capturedInputs = [];\n      capturedInputFrames.push(capturedInputs);\n      shouldCaptureNextInput = true;\n      block();\n      return capturedInputs;\n    } finally {\n      capturedInputFrames.pop();\n      shouldCaptureNextInput = false;\n    }\n  }\n\n  protected _addInput(input: BaseObservable<any>) {\n    this._inputs.push(input);\n    if (this._attachedToInputs) {\n      this._attachToInput(input);\n    }\n  }\n\n  protected _removeInput(input: BaseObservable<any>) {\n    this._inputs.splice(this._inputs.indexOf(input), 1);\n    if (this._attachedToInputs) {\n      this._detachFromInput(input);\n    }\n  }\n\n  private _shouldAttachToInputs(): boolean {\n    // Only attach to inputs when at least one listener is subscribed to the observable or to one of its outputs.\n    // This is done to avoid unused observables being references by their inputs, preventing garbage-collection.\n    return this._listeners.length > 0 || this._outputs.length > 0;\n  }\n\n  private _attachToInputs() {\n    if (!this._attachedToInputs && this._shouldAttachToInputs()) {\n      this._attachedToInputs = true;\n\n      // Since the observable was not attached to its inputs, its value may be outdated.\n      // Refresh it so that listeners will be called with the correct prevValue the next time an input changes.\n      this._val = this._evaluate();\n\n      this.onBecomeObserved();\n      plugins.onBecomeObserved(this);\n\n      for (const input of this._inputs) {\n        this._attachToInput(input);\n        input._attachToInputs();\n      }\n    }\n  }\n\n  private _detachFromInputs() {\n    if (this._attachedToInputs && !this._shouldAttachToInputs()) {\n      this._attachedToInputs = false;\n      for (const input of this._inputs) {\n        this._detachFromInput(input);\n        input._detachFromInputs();\n      }\n\n      this.onBecomeUnobserved();\n      plugins.onBecomeUnobserved(this);\n    }\n  }\n\n  private _attachToInput(input: BaseObservable<any>) {\n    input._outputs.push(this);\n    plugins.onAttach(this, input);\n  }\n\n  private _detachFromInput(input: BaseObservable<any>) {\n    input._outputs.splice(input._outputs.indexOf(this), 1);\n    plugins.onDetach(this, input);\n  }\n\n  private _addToBatchRecursively() {\n    if (this._prevVal === UNSET) {\n      this._prevVal = this._val;\n\n      // Add the observable and its outputs in reverse topological order\n      for (const output of this._outputs) {\n        output._addToBatchRecursively();\n      }\n      batchedObservables.push(this);\n    }\n  }\n\n  protected static _batch(block: () => void) {\n    try {\n      batchDepth++;\n      if (batchDepth === 1 && batchedUpdater) {\n        batchedUpdater(block);\n      } else {\n        block();\n      }\n    } finally {\n      batchDepth--;\n      if (batchDepth === 0) {\n        const observablesToUpdate = batchedObservables;\n        batchedObservables = [];\n\n        // Iterate in reverse order as _addToBatchRecursively() adds them in reverse topological order\n        for (let i = observablesToUpdate.length - 1; i >= 0; i--) {\n          const observable = observablesToUpdate[i];\n          const prevVal = observable._prevVal;\n          observable._prevVal = UNSET;\n          observable._val = observable._evaluate();\n          const val = observable._val;\n\n          if (val !== prevVal) {\n            for (const listener of observable._listeners.slice()) {\n              listener(val, prevVal);\n            }\n            plugins.onChange(observable, val, prevVal);\n          }\n        }\n      }\n    }\n  }\n\n  protected static _use(plugin: Plugin) {\n    plugins.use(plugin);\n  }\n}\n","import { BaseObservable, Options } from \"./baseObservable\";\nimport { memoize } from \"./memoize\";\nimport { Plugin } from \"./plugin\";\n\nexport type ObservableValue<T> = T extends Observable<infer U> ? U : never;\nexport type ObservableValues<T> = { [K in keyof T]: ObservableValue<T[K]> };\n\nexport function observable<T>(val: T | Observable<T>, options?: Options): WritableObservable<T> {\n  return new WritableObservable(val, options);\n}\n\nexport function derived<T>(derive: () => T): Observable<T> {\n  return Observable.compute(derive);\n}\n\nexport class Observable<T> extends BaseObservable<T> {\n  protected _valInput: Observable<T> | undefined;\n\n  constructor(val: T | Observable<T>, options?: Options) {\n    super(val instanceof Observable ? val.get() : val, options);\n    this._updateValInput(val);\n  }\n\n  protected _evaluate(): T {\n    return this._valInput ? this._valInput.get() : super._evaluate();\n  }\n\n  select<U>(selector: (val: T) => U | Observable<U>): Observable<U> {\n    return new DerivedObservable([this], ([val]) => selector(val));\n  }\n\n  /**\n   * @deprecated Use observable.select() instead\n   */\n  transform = this.select;\n\n  onlyIf(predicate: (val: T) => boolean): Observable<T | undefined> {\n    let filteredVal: T | undefined = undefined;\n    return this.select(val => {\n      if (predicate(val)) {\n        filteredVal = val;\n      }\n      return filteredVal;\n    });\n  }\n\n  default(defaultVal: NonNullable<T> | Observable<NonNullable<T>>): Observable<NonNullable<T>> {\n    return this.select(val => val ?? defaultVal);\n  }\n\n  as<U extends T>(): Observable<U> {\n    return (this as unknown) as Observable<U>;\n  }\n\n  static select<T extends readonly Observable<any>[], U>(\n    observables: [...T],\n    selector: (...vals: ObservableValues<T>) => U\n  ): Observable<U> {\n    return new DerivedObservable(observables, vals => selector(...vals));\n  }\n\n  /**\n   * @deprecated Use Observable.select() instead\n   */\n  static from<T extends Observable<any>[]>(...observables: T): Observable<ObservableValues<T>> {\n    return new DerivedObservable(observables, values => values);\n  }\n\n  static merge<T>(observables: Observable<T>[]): Observable<T[]> {\n    return new DerivedObservable(observables, values => values);\n  }\n\n  static latest<T extends Observable<any>[]>(...observables: T): Observable<ObservableValue<T[number]>> {\n    let prevValues: T[] | undefined;\n    return new DerivedObservable(observables, values => {\n      const val = !prevValues ? values[0] : values.find((it, index) => it !== prevValues![index])!;\n      prevValues = values;\n      return val;\n    });\n  }\n\n  static compute<U>(compute: () => U): Observable<U> {\n    return new ComputedObservable(compute);\n  }\n\n  static fromPromise<T, E = undefined>(\n    promise: Promise<T>,\n    onError?: (error: any) => E\n  ): Observable<T | E | undefined> {\n    const obs = observable<T | E | undefined>(undefined);\n    promise.then(\n      val => obs.set(val),\n      e => onError && obs.set(onError(e))\n    );\n    return obs;\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise(resolve => {\n      const unsubscribe = this.subscribe(val => {\n        resolve(val);\n        unsubscribe();\n      });\n    });\n  }\n\n  static batch(block: () => void) {\n    BaseObservable._batch(block);\n  }\n\n  static use(plugin: Plugin) {\n    BaseObservable._use(plugin);\n  }\n\n  protected _updateValInput(val: T | Observable<T>) {\n    if (this._valInput !== val) {\n      if (this._valInput) {\n        this._removeInput(this._valInput);\n        this._valInput = undefined;\n      }\n      if (val instanceof Observable) {\n        this._addInput(val);\n        this._valInput = val;\n      }\n    }\n  }\n}\n\nexport class WritableObservable<T> extends Observable<T> {\n  set(val: T | Observable<T>) {\n    this._updateValInput(val);\n    Observable.batch(() => this._set(val instanceof Observable ? val.get() : val));\n  }\n\n  update(updater: (val: T) => T | Observable<T>) {\n    this.set(updater(this.get()));\n  }\n\n  readOnly(): Observable<T> {\n    return this;\n  }\n}\n\nclass DerivedObservable<T, U extends Observable<any>[]> extends Observable<T> {\n  private _compute: (vals: ObservableValues<U>) => T | Observable<T>;\n  private _computeInputs: U;\n\n  constructor(computeInputs: U, compute: (vals: ObservableValues<U>) => T | Observable<T>) {\n    // No need to initialize it as it will be evaluated the first time get() or subscribe() is called\n    super(undefined as any);\n    this._compute = memoize(compute);\n    this._computeInputs = computeInputs;\n    for (const input of computeInputs) {\n      this._addInput(input);\n    }\n  }\n\n  _evaluate(): T {\n    const computed = this._compute(this._computeInputs.map(input => input.get()) as ObservableValues<U>);\n    this._updateValInput(computed);\n    return computed instanceof Observable ? computed.get() : computed;\n  }\n}\n\nclass ComputedObservable<T> extends Observable<T> {\n  private _compute: () => T;\n  private _currentInputs = new Set<BaseObservable<any>>();\n\n  constructor(compute: () => T) {\n    // No need to initialize it as it will be evaluated the first time get() or subscribe() is called\n    super(undefined as any);\n    this._compute = compute;\n  }\n\n  _evaluate(): T {\n    let value!: T;\n\n    const inputs = new Set(BaseObservable._captureInputs(() => (value = this._compute())));\n    inputs.forEach(input => {\n      if (!this._currentInputs.has(input)) {\n        this._addInput(input);\n      } else {\n        this._currentInputs.delete(input);\n      }\n    });\n    this._currentInputs.forEach(input => this._removeInput(input));\n    this._currentInputs = inputs;\n\n    return value;\n  }\n}\n","export function memoize<T extends any[], U>(func: (args: T) => U): (args: T) => U {\n  let lastArgs: T | undefined;\n  let lastResult!: U;\n\n  return (args: T) => {\n    let argsHaveChanged = false;\n    if (!lastArgs || args.length !== lastArgs.length) {\n      argsHaveChanged = true;\n    } else {\n      for (let i = 0; i < args.length; i++) {\n        if (args[i] !== lastArgs[i]) {\n          argsHaveChanged = true;\n          break;\n        }\n      }\n    }\n\n    if (argsHaveChanged) {\n      lastArgs = args;\n      lastResult = func(args);\n    }\n\n    return lastResult;\n  };\n}\n","import { useLayoutEffect, useMemo, useState } from \"react\";\nimport { Observable } from \"./observable\";\n\nexport function useObservable<T>(observable: Observable<T>): T {\n  const [, forceRender] = useState({});\n  const val = observable.get();\n\n  useLayoutEffect(() => {\n    return observable.subscribe(() => forceRender({}));\n  }, [observable]);\n\n  return val;\n}\n\nexport function useMemoizedObservable<T>(factory: () => Observable<T>, deps: any[] = []): T {\n  return useObservable(useMemo(factory, deps));\n}\n\nexport function useComputedObservable<T>(compute: () => T, deps: any[] = []): T {\n  return useMemoizedObservable(() => Observable.compute(compute), deps);\n}\n","// Code ported from React source-code\n\nfunction is(x: any, y: any): boolean {\n  return (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\n\nexport function shallowEqual(objA: any, objB: any): boolean {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!objB.hasOwnProperty(keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","export type BatchedUpdater = (block: () => void) => void;\n\nexport let batchedUpdater: BatchedUpdater | undefined;\n\nexport function setBatchedUpdater(updater: BatchedUpdater | undefined) {\n  batchedUpdater = updater;\n}\n","import hoistNonReactStatics from \"hoist-non-react-statics\";\nimport React from \"react\";\nimport { Unsubscriber } from \"./baseObservable\";\nimport { Observable, ObservableValues } from \"./observable\";\nimport { shallowEqual } from \"./shallowEqual\";\n\ntype Mapping = { [key: string]: Observable<any> };\ntype InjectedProps<M extends Mapping> = ObservableValues<M>;\ntype HocProps<P extends InjectedProps<M>, M extends Mapping> = Pick<P, Exclude<keyof P, keyof M>>;\n\nexport const withObservables = <P extends InjectedProps<M>, M extends Mapping>(\n  Component: React.ComponentType<P>,\n  mapping: (ownProps: HocProps<P, M>) => M\n): React.ComponentType<HocProps<P, M>> => {\n  class WithObservables extends React.PureComponent<HocProps<P, M>> {\n    private _ownProps!: HocProps<P, M>;\n    private _mapping!: M;\n    private _unsubscribers: Unsubscriber[] = [];\n\n    componentWillUnmount() {\n      this._unsubscribers.forEach(it => it());\n      this._unsubscribers = [];\n    }\n\n    render(): JSX.Element {\n      this.updateMapping();\n\n      const injectedProps: { [key: string]: any } = {};\n      for (const key of Object.keys(this._mapping)) {\n        injectedProps[key] = this._mapping[key].get();\n      }\n\n      return React.createElement(Component, { ...this.props, ...injectedProps } as P);\n    }\n\n    private updateMapping() {\n      if (!this._ownProps || !shallowEqual(this._ownProps, this.props)) {\n        this._ownProps = this.props;\n        this._mapping = typeof mapping === \"function\" ? mapping(this.props) : mapping;\n\n        const unsubscribers = Object.values(this._mapping).map(observable =>\n          observable.subscribe(() => this.forceUpdate())\n        );\n        this._unsubscribers.forEach(it => it());\n        this._unsubscribers = unsubscribers;\n      }\n    }\n  }\n  return hoistNonReactStatics(WithObservables, Component);\n};\n"],"names":["PluginManager","use","plugin","_plugins","push","onCreate","observable","val","forEach","it","onChange","prevVal","onBecomeObserved","onBecomeUnobserved","onAttach","input","onDetach","UNSET","Symbol","plugins","capturedInputFrames","shouldCaptureNextInput","batchedObservables","batchDepth","BaseObservable","options","this","subscribe","_val","_options","get","capturedInputs","length","_get","_attachedToInputs","_prevVal","_evaluate","_set","_addToBatchRecursively","listener","_listeners","_attachToInputs","listenerRemoved","_this","splice","indexOf","_detachFromInputs","getInputs","_inputs","getOptions","withOptions","_captureInputs","block","pop","_addInput","_attachToInput","_removeInput","_detachFromInput","_shouldAttachToInputs","_outputs","_batch","batchedUpdater","observablesToUpdate","i","slice","_use","WritableObservable","Observable","select","_updateValInput","_valInput","selector","DerivedObservable","onlyIf","predicate","filteredVal","undefined","defaultVal","as","observables","vals","from","values","merge","latest","prevValues","find","index","compute","ComputedObservable","fromPromise","promise","onError","obs","then","set","e","toPromise","Promise","resolve","unsubscribe","_this2","batch","_this3","update","updater","readOnly","computeInputs","func","lastArgs","lastResult","_compute","args","argsHaveChanged","_computeInputs","computed","map","Set","value","inputs","_this6","_currentInputs","has","useObservable","forceRender","useState","useLayoutEffect","useMemoizedObservable","factory","deps","useMemo","is","x","y","derive","Component","mapping","hoistNonReactStatics","componentWillUnmount","_unsubscribers","render","updateMapping","injectedProps","Object","keys","_mapping","key","React","createElement","props","_ownProps","objA","objB","keysA","keysB","hasOwnProperty","shallowEqual","unsubscribers","forceUpdate","PureComponent"],"mappings":"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"}